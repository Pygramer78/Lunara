ğŸ©µ Fase 1: DiseÃ±o del lenguaje (1â€“2 meses)

â€œAntes de escribir cÃ³digo, diseÃ±a cÃ³mo se sentirÃ¡ escribir en Lunara.â€

Objetivos tÃ©cnicos:

Define quÃ© tipos de datos tendrÃ¡ (int, float, string, list, etc.).

Decide cÃ³mo serÃ¡ la sintaxis (similar a Python, Ruby, o algo Ãºnico).

Define el flujo de control:

let x = 3
if x > 2:
    print("grande")
else:
    print("pequeÃ±o")


Crea un documento de especificaciÃ³n simple: Lunara Language Spec v0.1

Reto creativo:
DiseÃ±a que leer cÃ³digo en Lunara se sienta como â€œpensar en voz altaâ€.
Por ejemplo:

when sky == "dark":
    light("stars")

ğŸ’« Fase 2: Analizador lÃ©xico (lexer) (1â€“2 meses)

â€œHaz que Lunara aprenda a leer sus propias palabras.â€

Objetivos tÃ©cnicos:

Escribe un lexer que recorra el cÃ³digo y divida en tokens (palabras, nÃºmeros, sÃ­mbolos).

Ejemplo de tokens:

let â†’ KEYWORD
x â†’ IDENTIFIER
= â†’ ASSIGN
3 â†’ NUMBER


Implementa en Python (mÃ¡s rÃ¡pido para empezar) o Rust (si prefieres control).

Reto creativo:
Haz que el lexer reconozca palabras clave elegantes, no solo tÃ©cnicas:

whisper "hola"


podrÃ­a ser alias de print("hola").

âš™ï¸ Fase 3: Parser y AST (2â€“3 meses)

â€œDe los tokens al pensamiento estructurado.â€

Objetivos tÃ©cnicos:

Implementa un parser recursivo o con una librerÃ­a (lark, chumsky, etc.).

Convierte la lista de tokens en un Ã¡rbol de sintaxis abstracta (AST).

Ejemplo:

let x = 3 + 2


â†’ AST:

Assign
 â”œâ”€â”€ Identifier(x)
 â””â”€â”€ Add
     â”œâ”€â”€ Number(3)
     â””â”€â”€ Number(2)


Reto creativo:
DiseÃ±a una forma de visualizar el AST (por consola o grÃ¡fico).
AsÃ­ puedes â€œverâ€ cÃ³mo Lunara entiende el cÃ³digo.

ğŸ”® Fase 4: IntÃ©rprete (nÃºcleo) (4â€“6 meses)

â€œHaz que Lunara piense.â€

Objetivos tÃ©cnicos:

Implementa una funciÃ³n evaluate(node) que recorra el AST y ejecute cada nodo.

Crea un entorno de variables (diccionario o mapa).

Soporta operaciones bÃ¡sicas: aritmÃ©tica, asignaciones, condicionales, bucles, funciones.

Implementa un sistema de errores con mensajes claros:

ğŸŒ™ RuntimeError: undefined variable 'dream'


Reto creativo:
Cada valor puede tener propiedades poÃ©ticas o artÃ­sticas:
por ejemplo, color, tone, weight, etc., si planeas usarlo en proyectos creativos.

ğŸ§° Fase 5: LibrerÃ­a estÃ¡ndar (3â€“4 meses)

â€œDale herramientas para crear.â€

Objetivos tÃ©cnicos:

Implementa funciones nativas (print, len, type, etc.).

Crea mÃ³dulos simples (math, string, io).

Permite importar otros archivos .ln.

Reto creativo:
Crea mÃ³dulos â€œartÃ­sticosâ€:

import wave
sound = wave.new(freq:440, duration:2)
sound.play()

ğŸŒ Fase 6: CLI y REPL (1â€“2 meses)

â€œHabla con Lunara en tiempo real.â€

Objetivos tÃ©cnicos:

Programa un ejecutable:

$ lunara script.ln


Implementa un REPL interactivo (como el de Python):

>>> let x = 10
>>> x * 2
20


Reto creativo:
Haz que el prompt sea Ãºnico, ejemplo:

ğŸŒ™ >>


o incluso tenga â€œmodo nocturnoâ€.

ğŸª„ Fase 7: Ecosistema y expansiÃ³n (resto del tiempo)

â€œLunara aprende a crear su propio mundo.â€

Implementa un sistema de mÃ³dulos (import real).

AÃ±ade un sistema de objetos o clases simples.

Crea una mini documentaciÃ³n autogenerada.

Si te animas: un editor visual o web REPL para Lunara.

Publica en GitHub y crea una documentaciÃ³n estilo lenguaje real.


Herramientas recomendadas
PropÃ³sito	OpciÃ³n 1	OpciÃ³n 2
Lenguaje	Python (fÃ¡cil de iterar)	Rust (rÃ¡pido y sÃ³lido)
Parsing	lark-parser, ply	pest, chumsky
Testing	pytest	cargo test
Docs	Markdown + MkDocs	mdBook
Repositorio	GitHub + Releases

âœ¨ Idea para la filosofÃ­a de Lunara

â€œEl cÃ³digo es poesÃ­a que se ejecuta.â€

Lema: â€œProgramar deberÃ­a sentirse como crear arte.â€

Paradigma: imperativo con toques funcionales.

Tipado: dinÃ¡mico y flexible.

Enfoque: scripts, expresividad y prototipado artÃ­stico.

lunara/
â”œâ”€â”€ include/
â”‚   â”œâ”€â”€ lexer.h
â”‚   â”œâ”€â”€ parser.h
â”‚   â”œâ”€â”€ eval.h
â”‚   â”œâ”€â”€ env.h
â”‚   â”œâ”€â”€ builtins.h
â”‚   â””â”€â”€ lunara.h        
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ lexer.c
â”‚   â”œâ”€â”€ parser.c
â”‚   â”œâ”€â”€ eval.c
â”‚   â”œâ”€â”€ env.c
â”‚   â”œâ”€â”€ builtins.c
â”‚   â””â”€â”€ main.c
â”œâ”€â”€ examples/
â”‚   â””â”€â”€ hello.luna
â””â”€â”€ Makefile

Reglas de oro

Cada .c solo incluye lo que necesita.
No incluyas todos los headers en todos lados; solo los necesarios.

Nunca definas funciones en .h.
Solo las declaras (sus prototipos). El cÃ³digo va en .c.

Usa include guards (#ifndef/#define/#endif).
Evita conflictos de doble inclusiÃ³n.

Incluye lunara.h solo en main.c (y tal vez en pruebas).
AsÃ­ mantienes los mÃ³dulos independientes
